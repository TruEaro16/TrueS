#include <iostream>
#include <fstream>
#include <cmath>

int main() {
    // Чтение CSR матрицы из файла
    const char* matrixFile = "test_int";
    std::ifstream file(matrixFile);
    if (!file.is_open()) {
        std::cerr << "Error opening file: " << matrixFile << std::endl;
        return EXIT_FAILURE;
    }

    int n, nnz;
    file >> n >> nnz;

    int* rowPtr = new int[n + 1];
    int* colIdx = new int[nnz];
    double* values = new double[nnz];

    for (int i = 0; i <= n; ++i) {
        file >> rowPtr[i];
    }

    for (int i = 0; i < nnz; ++i) {
        file >> colIdx[i];
    }

    for (int i = 0; i < nnz; ++i) {
        file >> values[i];
    }

    file.close();

    // Чтение вектора из файла
    const char* vectorFile = "BB";
    std::ifstream vecFile(vectorFile);
    if (!vecFile.is_open()) {
        std::cerr << "Error opening file: " << vectorFile << std::endl;
        delete[] rowPtr;
        delete[] colIdx;
        delete[] values;
        return EXIT_FAILURE;
    }

    double* b = new double[n];
    for (int i = 0; i < n; ++i) {
        vecFile >> b[i];
    }

    vecFile.close();

    // Ортогонализация матрицы методом полной ортогонализации Грама-Шмидта
    double* Q = new double[n * n];

    for (int k = 0; k < n; ++k) {
        double* q = new double[n];
        for (int i = 0; i < n; ++i) {
            q[i] = 0.0;
        }
        for (int i = rowPtr[k]; i < rowPtr[k + 1]; ++i) {
            q[colIdx[i]] = values[i];
        }

        for (int j = 0; j < k; ++j) {
            double r = 0.0;
            for (int i = 0; i < n; ++i) {
                r += Q[j * n + i] * q[i];
            }
            for (int i = 0; i < n; ++i) {
                q[i] -= r * Q[j * n + i];
            }
        }

        double norm = 0.0;
        for (int i = 0; i < n; ++i) {
            norm += q[i] * q[i];
        }
        norm = std::sqrt(norm);
        for (int i = 0; i < n; ++i) {
            Q[k * n + i] = q[i] / norm;
        }

        delete[] q;
    }

    // Освобождение памяти
    delete[] rowPtr;
    delete[] colIdx;
    delete[] values;
    delete[] b;
    delete[] Q;

    return 0;
}
