#include <iostream>     // Для работы с вводом/выводом
#include <cmath>        // Для математических функций, таких как sin, cos, pow
#include <iomanip>      // Для форматирования вывода (точность вывода)

using namespace std;    // Упрощает использование стандартных функций, таких как cout и endl

// Функция f(x) = x^2 - 10*sin^2(x) + 2
// Это исходная функция, корень которой мы будем искать
double f(double x) {
    return x * x - 10 * pow(sin(x), 2) + 2;  // Возвращает значение функции в точке x
}

// Производная f'(x) = 2*x - 20*sin(x)*cos(x)
// Производная нужна для метода Ньютона, чтобы корректировать приближение корня
double f_prime(double x) {
    return 2 * x - 20 * sin(x) * cos(x);  // Возвращает значение производной функции в точке x
}

// Реализация метода Ньютона для поиска корня
// a и b - начальный интервал, tolerance - точность, max_iter - максимальное количество итераций
void newton_method(double a, double b, double tolerance, int max_iter) {
    // Динамическое выделение памяти для хранения текущего приближения корня
    double* x = new double;

    // Начальное приближение x0, которое можно взять как середину интервала [a, b]
    *x = (a + b) / 2.0;
    
    int iter = 0;  // Счетчик итераций

    // Основной цикл метода Ньютона, который будет выполняться до достижения точности
    while (iter < max_iter) {
        double fx = f(*x);       // Вычисляем значение функции в текущей точке x
        double fpx = f_prime(*x); // Вычисляем значение производной функции в текущей точке x

        // Проверяем, не слишком ли производная близка к нулю, чтобы избежать деления на ноль
        if (fabs(fpx) < 1e-10) {
            cout << "Производная слишком близка к нулю, метод не применим." << endl;
            break;  // Прерываем выполнение, если производная близка к нулю
        }

        // Вычисляем новое приближение по формуле метода Ньютона: x1 = x0 - f(x0) / f'(x0)
        double next_x = *x - fx / fpx;

        // Проверка на достижение требуемой точности (разница между новым и текущим значением)
        if (fabs(next_x - *x) < tolerance) {
            *x = next_x;  // Обновляем текущее значение корня
            cout << "Найденный корень: " << setprecision(10) << *x << endl;  // Выводим найденный корень
            cout << "Количество итераций: " << iter << endl;  // Выводим количество итераций
            break;  // Прерываем цикл, если достигли необходимой точности
        }

        // Обновляем текущее приближение для следующей итерации
        *x = next_x;
        iter++;  // Увеличиваем счетчик итераций
    }

    // Если максимальное количество итераций было достигнуто, сообщаем об этом
    if (iter == max_iter) {
        cout << "Метод не сошелся за " << max_iter << " итераций." << endl;
    }

    // Освобождаем память, которую выделили для хранения текущего приближения
    delete x;
}

// Главная функция программы
int main() {
    double a = -1, b = 3;        // Начальный интервал, где будем искать корень
    double tolerance = 1e-6;     // Точность (насколько близко должны подойти к корню)
    int max_iter = 1000;         // Максимальное количество итераций, чтобы избежать зацикливания

    // Вызываем метод Ньютона для нахождения корня на интервале [a, b]
    newton_method(a, b, tolerance, max_iter);

    return 0;  // Возвращаем 0, чтобы показать успешное завершение программы
}
