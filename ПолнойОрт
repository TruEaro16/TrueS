#include <iostream>
#include <fstream>
#include <cmath>

using namespace std;

int main() {
    // Чтение CSR матрицы из файла
    fstream file;
    file.open("C:\\Users\\stud\\Desktop\\Test_int.mtx");
    if (!file.is_open()) {
        cout << "Matrix file not open " << endl;
        return EXIT_FAILURE;
    }

    int n, m, nnz;
    file >> n >> m >> nnz;

    int* rowPtr = new int[n + 1];
    int* colIdx = new int[nnz];
    double* values = new double[nnz];

    for (int i = 0; i <= n; ++i) {
        file >> rowPtr[i];
    }

    for (int i = 0; i < nnz; ++i) {
        file >> colIdx[i];
    }

    for (int i = 0; i < nnz; ++i) {
        file >> values[i];
    }

    file.close();

    // Чтение вектора из файла
    fstream vecFile;
    vecFile.open("C:\\Users\\stud\\Desktop\\BB.txt");
    if (!vecFile.is_open()) {
        cout << "Vector file not open " << endl;
        delete[] rowPtr;
        delete[] colIdx;
        delete[] values;
        return EXIT_FAILURE;
    }

    double* b = new double[n];
    for (int i = 0; i < n; ++i) {
        vecFile >> b[i];
    }

    vecFile.close();

    // Ортогонализация методом Грама-Шмидта
    double* Q = new double[n * n];
    double* R = new double[n * n];

    for (int i = 0; i < n * n; ++i) {
        Q[i] = 0.0;
        R[i] = 0.0;
    }

    for (int k = 0; k < n; ++k) {
        double* q = new double[n]();

        // Копируем значения из CSR матрицы в вектор q
        for (int i = rowPtr[k]; i < rowPtr[k + 1]; ++i) {
            q[colIdx[i]] = values[i];
        }

        // Ортогонализация
        for (int j = 0; j < k; ++j) {
            double r = 0.0;
            for (int i = 0; i < n; ++i) {
                r += Q[j * n + i] * q[i];
            }
            R[j * n + k] = r;
            for (int i = 0; i < n; ++i) {
                q[i] -= r * Q[j * n + i];
            }
        }

        // Вычисление нормы и проверка на сингулярность
        double norm = 0.0;
        for (int i = 0; i < n; ++i) {
            norm += q[i] * q[i];
        }
        norm = sqrt(norm);

        // Если норма равна нулю, матрица сингулярна
        if (norm == 0) {
            cout << "Matrix is singular and cannot be orthogonalized." << endl;
            delete[] q;
            delete[] rowPtr;
            delete[] colIdx;
            delete[] values;
            delete[] b;
            delete[] Q;
            delete[] R;
            return EXIT_FAILURE;
        }
        R[k * n + k] = norm;
        for (int i = 0; i < n; ++i) {
            Q[k * n + i] = q[i] / norm;
        }

        delete[] q;
    }

    // Решение уравнения R * x = Q^T * b
    double* Qtb = new double[n];
    for (int i = 0; i < n; ++i) {
        Qtb[i] = 0.0;
        for (int j = 0; j < n; ++j) {
            Qtb[i] += Q[j * n + i] * b[j];
        }
    }

    double* x = new double[n];
    for (int i = n - 1; i >= 0; --i) {
        x[i] = Qtb[i];
        for (int j = i + 1; j < n; ++j) {
            x[i] -= R[i * n + j] * x[j];
        }
        x[i] /= R[i * n + i];
    }

    // Вывод решения
    cout << "Solution vector x:" << endl;
    for (int i = 0; i < n; ++i) {
        cout << x[i] << " ";
    }
    cout << endl;

    // Освобождение памяти
    delete[] rowPtr;
    delete[] colIdx;
    delete[] values;
    delete[] b;
    delete[] Q;
    delete[] R;
    delete[] Qtb;
    delete[] x;

    return 0;
}

10 10 36
1 1 10
1 3 1
1 6 2
1 7 3
1 10 4
2 2 11
2 7 6
3 1 1
3 3 12
3 5 5
3 9 6
4 4 13
4 6 8
4 8 7
4 10 -3
5 3 5
5 5 14
5 8 -1
6 1 2
6 4 8
6 6 15
6 10 9
7 1 3
7 2 6
7 7 16
7 9 -2
8 4 7
8 5 -1
8 8 17
9 3 6
9 7 -2
9 9 18
10 1 4
10 4 -3
10 6 9
10 10 19
