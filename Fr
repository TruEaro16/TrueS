#include <iostream>
#include <variant>
#include <string>

using namespace std;

// Определяем тип данных для хранения имени, возраста и среднего балла
using StudentInfo = variant<string, int, double>;

// Функция для вывода информации о студенте в зависимости от переданного типа данных
void print_student_info(const StudentInfo& info) {
    if (holds_alternative<string>(info)) {
        cout << "Имя: " << get<string>(info) << endl;
    } else if (holds_alternative<int>(info)) {
        cout << "Возраст: " << get<int>(info) << endl;
    } else if (holds_alternative<double>(info)) {
        cout << "Средний балл: " << get<double>(info) << endl;
    } else {
        cout << "Неизвестный тип данных" << endl;
    }
}

int main() {
    // Создаем несколько вариантов данных о студенте
    StudentInfo name = "Иван Иванов";
    StudentInfo age = 21;
    StudentInfo avg_score = 4.8;

    // Вызываем функцию для вывода информации
    print_student_info(name);      // Вывод имени
    print_student_info(age);       // Вывод возраста
    print_student_info(avg_score); // Вывод среднего балла

    return 0;
}


#include <iostream>
#include <tuple>
#include <string>

using namespace std;

int main() {
    // Создаем кортеж с информацией о студенте
    tuple<string, int, double> student = make_tuple("Иван Иванов", 20, 4.5);

    // Используем структурированные привязки для получения значений
    auto [name, age, avg_score] = student;

    // Выводим значения
    cout << "Имя: " << name << endl;
    cout << "Возраст: " << age << endl;
    cout << "Средний балл: " << avg_score << endl;

    return 0;
}

#include <iostream>
#include <map>
#include <string>

using namespace std;

int main() {
    // Карта для хранения информации о студентах (имя -> возраст)
    map<string, int> students = {{"Иван Иванов", 20}, {"Анна Петрова", 22}, {"Олег Сидоров", 19}};

    // Перебор элементов карты с использованием структурированных привязок
    for (const auto& [name, age] : students) {
        cout << "Имя: " << name << ", Возраст: " << age << endl;
    }

    return 0;
}
