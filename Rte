#include<iostream>
#include <math.h>
#include <stdlib.h>
#include <fstream>
#include <vector>
using namespace std;

struct List {
    double* AV;    // Array of non-zero matrix elements
    int* ANR;      // Array of corresponding row indices
    int* ANL;      // Array with starting points of columns in AV and ANR
    int n, k;      // Dimension of the matrix and number of non-zero elements
    double* b;     // Right-hand side vector
};

void readCSCMatrix(ifstream& file, List& A) {
    int n, k;
    file >> n >> k;
    A.n = n;
    A.k = k;
    A.AV = new double[k];
    A.ANR = new int[k];
    A.ANL = new int[n+1];
    A.b = new double[n];
    for (int i = 0; i < n; ++i) {
        file >> A.b[i];
    }
    for (int i = 0; i < n+1; ++i) {
        file >> A.ANL[i];
    }
    for (int i = 0; i < k; ++i) {
        file >> A.ANR[i];
    }
    for (int i = 0; i < k; ++i) {
        file >> A.AV[i];
    }
}

void SteepestDescent(List& A, double* x) {
    double* r = new double[A.n];
    double* p = new double[A.n];
    double alpha, rsold, rsnew;
    double tol = 1e-8;
    int max_iter = 1000;

    // Initial guess (zero vector)
    for (int i = 0; i < A.n; ++i) {
        x[i] = 0;
    }

    // Compute initial residual r = b - Ax, here A*x is initially zero
    for (int i = 0; i < A.n; ++i) {
        r[i] = A.b[i];
        p[i] = r[i];
    }

    rsold = 0;
    for (int i = 0; i < A.n; ++i) {
        rsold += r[i] * r[i];
    }

    for (int it = 0; it < max_iter && rsold > tol*tol; ++it) {
        double* Ap = new double[A.n]();
        for (int j = 0; j < A.n; ++j) {
            for (int k = A.ANL[j]; k < A.ANL[j+1]; ++k) {
                Ap[j] += A.AV[k] * p[A.ANR[k]];
            }
        }

        double pAp = 0;
        for (int i = 0; i < A.n; ++i) {
            pAp += p[i] * Ap[i];
        }

        alpha = rsold / pAp;
        for (int i = 0; i < A.n; ++i) {
            x[i] += alpha * p[i];
            r[i] -= alpha * Ap[i];
        }

        rsnew = 0;
        for (int i = 0; i < A.n; ++i) {
            rsnew += r[i] * r[i];
        }

        for (int i = 0; i < A.n; ++i) {
            p[i] = r[i];
        }

        rsold = rsnew;
        delete[] Ap;
    }

    delete[] r;
    delete[] p;
}

int main() {
    List A;
    double* x;
    ifstream file("matrix.txt");
    readCSCMatrix(file, A);
    x = new double[A.n];
    SteepestDescent(A, x);

    for (int i = 0; i < A.n; ++i) {
        cout << x[i] << " ";
    }
    cout << endl;

    delete[] x;
    delete[] A.AV;
    delete[] A.ANR;
    delete[] A.ANL;
    delete[] A.b;

    return 0;
}
```

Обратите внимание на следующие моменты в коде:
- Начальное приближение \( x_0 \) — нулевой вектор.
- Шаги алгоритма реализованы в функции `SteepestDescent`.
- Ввод/вывод и структура хранения данных соответствуют формату CSC.

Этот код следует проверить на корректность и эффективность, учитывая, что он предполагает использование исключительно симметричных и положительно определённых матриц.
