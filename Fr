#include <iostream>
#include <cmath>

using namespace std;

// Подынтегральная функция f(x) = 1 / (x + sin(0.1 * n * x))
// Эта функция возвращает значение подынтегральной функции в точке x для заданного параметра n
double f(double x, double n) {
    return 1.0 / (x + sin(0.1 * n * x));
}

// Функция для вычисления полинома ω(x) для заданных узлов
// ω(x) = ∏_{k=0}^{N} (x - x_k) (кроме x_i)
// Возвращает значение ω(x) для точки x и заданного узла x_i
double omega(double x, double* nodes, int N) {
    double result = 1.0;
    for (int k = 0; k <= N; ++k) {
        result *= (x - nodes[k]);
    }
    return result;
}

// Функция для вычисления весового коэффициента C_i
// Вычисляем C_i по формуле (24)
double calculate_Ci(int i, double* nodes, int N, double a, double b) {
    // Численное интегрирование с весовой функцией
    double Ci = 0.0;
    int steps = 1000;  // Количество шагов для численного интегрирования
    double h = (b - a) / steps;  // Шаг интегрирования

    for (int j = 0; j < steps; ++j) {
        double x = a + j * h;  // Текущая точка на интервале интегрирования
        Ci += omega(x, nodes, N) / ((x - nodes[i]) * omega(nodes[i], nodes, N));  // Формула (24)
    }

    Ci *= h;  // Умножаем на шаг интегрирования для получения приближенного значения
    return Ci;
}

// Функция для вычисления максимальной производной (N+1)-ой степени для оценки погрешности
double max_derivative(double a, double b) {
    // Предположим, что производная оценивается численно как максимум значения функции на интервале
    double max_value = 0.0;
    int steps = 1000;
    double h = (b - a) / steps;

    for (int j = 0; j < steps; ++j) {
        double x = a + j * h;
        double derivative_value = fabs(sin(x));  // Примерная производная
        if (derivative_value > max_value) {
            max_value = derivative_value;
        }
    }
    
    return max_value;
}

int main() {
    double n = 5.0;  // Параметр n для подынтегральной функции
    double a = 0.2 * n;  // Нижний предел интегрирования (0.2 * n)
    double b = 2.0 * n;  // Верхний предел интегрирования (2 * n)
    int N = 2;  // Количество узлов интерполяции

    // Массив для хранения узлов интерполяции
    double* nodes = new double[N + 1];
    
    // Определим равномерные узлы на отрезке [a, b]
    for (int i = 0; i <= N; ++i) {
        nodes[i] = a + i * (b - a) / N;
    }

    // Переменная для хранения значения интеграла
    double integral = 0.0;

    // Шаг 1: Вычисляем значение интеграла с использованием формул интерполяционного типа
    for (int i = 0; i <= N; ++i) {
        // Шаг 2: Вычисляем весовой коэффициент C_i
        double Ci = calculate_Ci(i, nodes, N, a, b);
        // Шаг 3: Добавляем вклад каждого узла в интеграл (C_i * f(x_i))
        integral += Ci * f(nodes[i], n);
    }

    // Шаг 4: Оценка погрешности по последней формуле
    double max_N1_derivative = max_derivative(a, b);  // Максимальная производная (N+1)-го порядка
    double error_estimate = (b - a) * max_N1_derivative / (N + 1);

    // Выводим результат
    cout << "Значение интеграла I1 с использованием формул интерполяционного типа = " << integral << endl;
    cout << "Оценка погрешности: " << error_estimate << endl;

    // Освобождаем динамически выделенную память
    delete[] nodes;

    return 0;
}
