#include <fstream>
#include <iostream>
#include <cmath>

using namespace std;

int main() {
    setlocale(LC_ALL, "Russian");
    fstream f, br;
    f.open("C:\\Users\\stud\\Desktop\\Test_int.mtx");
    br.open("C:\\Users\\stud\\Desktop\\BB.txt");

    if (!f.is_open()) {
        cout << "Matrix file not open" << endl;
        return EXIT_FAILURE;
    }
    if (!br.is_open()) {
        cout << "Vector file not open" << endl;
        return EXIT_FAILURE;
    }

    int n, m, Nenol;
    f >> n >> m >> Nenol;

    // Выделяем память под массивы
    double* AV = new double[Nenol]();
    int* numCols = new int[Nenol]();
    int* numRows = new int[Nenol]();
    double* b = new double[n](); // Вектор b
    double* Q = new double[n * n]();
    double* R = new double[n * n]();
    double* x = new double[n]();

    // Чтение вектора b из файла
    for (int i = 0; i < n; i++) {
        if (!(br >> b[i])) {
            cout << "b не считался." << endl;
            delete[] AV;
            delete[] numCols;
            delete[] numRows;
            delete[] b;
            delete[] Q;
            delete[] R;
            delete[] x;
            return EXIT_FAILURE;
        }
    }

    for (int i = 0; i < Nenol; i++) {
        f >> numRows[i] >> numCols[i] >> AV[i];
        numRows[i]--; // Переводим в нумерацию с 0
        numCols[i]--;
    }

    f.close();
    br.close();

    // Ортогонализация методом Грама-Шмидта
    for (int k = 0; k < n; ++k) {
        double* q = new double[n]();

        // Копируем значения из CSR матрицы в вектор q
        for (int i = 0; i < Nenol; ++i) {
            if (numRows[i] == k) {
                q[numCols[i]] = AV[i];
            }
        }

        // Отладочный вывод для вектора q
        cout << "q[" << k << "]: ";
        for (int i = 0; i < n; ++i) {
            cout << q[i] << " ";
        }
        cout << endl;

        // Ортогонализация
        for (int j = 0; j < k; ++j) {
            double r = 0.0;
            for (int i = 0; i < n; ++i) {
                r += Q[j * n + i] * q[i];
            }
            R[j * n + k] = r;
            for (int i = 0; i < n; ++i) {
                q[i] -= r * Q[j * n + i];
            }
        }

        // Вычисление нормы и проверка на сингулярность
        double norm = 0.0;
        for (int i = 0; i < n; ++i) {
            norm += q[i] * q[i];
        }
        norm = sqrt(norm);

        // Если норма равна нулю, матрица сингулярна
        if (norm == 0) {
            cout << "Matrix is singular and cannot be orthogonalized." << endl;
            delete[] q;
            delete[] AV;
            delete[] numCols;
            delete[] numRows;
            delete[] b;
            delete[] Q;
            delete[] R;
            delete[] x;
            return EXIT_FAILURE;
        }
        R[k * n + k] = norm;
        for (int i = 0; i < n; ++i) {
            Q[k * n + i] = q[i] / norm;
        }

        delete[] q;
    }

    // Вывод матрицы Q и R для отладки
    cout << "Матрица Q:" << endl;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            cout << Q[i * n + j] << " ";
        }
        cout << endl;
    }

    cout << "Матрица R:" << endl;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            cout << R[i * n + j] << " ";
        }
        cout << endl;
    }

    // Решение уравнения R * x = Q^T * b
    double* Qtb = new double[n]();
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            Qtb[i] += Q[j * n + i] * b[j];
        }
    }

    cout << "Q^T * b: ";
    for (int i = 0; i < n; ++i) {
        cout << Qtb[i] << " ";
    }
    cout << endl;

    for (int i = n - 1; i >= 0; --i) {
        x[i] = Qtb[i];
        for (int j = i + 1; j < n; ++j) {
            x[i] -= R[i * n + j] * x[j];
        }
        x[i] /= R[i * n + i];
    }

    // Вывод решения
    cout << "Результат x:" << endl;
    for (int i = 0; i < n; i++) {
        cout << x[i] << " ";
    }
    cout << endl;

    // Освобождение памяти
    delete[] AV;
    delete[] numCols;
    delete[] numRows;
    delete[] b;
    delete[] Q;
    delete[] R;
    delete[] Qtb;
    delete[] x;

    return 0;
}
