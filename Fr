#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <string>

using namespace std;

// Структура узла (точка)
struct Node {
    int id;
    double x, y, z;
};

// Структура элемента (линия, треугольник и т. д.)
struct Element {
    int id;
    int type;
    vector<int> node_ids;
};

// Класс для работы с сеткой
class Mesh {
public:
    vector<Node> nodes;
    vector<Element> elements;

    // Функция загрузки .msh файла
    bool loadMesh(const string& filename) {
        ifstream file(filename);
        if (!file.is_open()) {
            cerr << "Ошибка: Не удалось открыть файл " << filename << endl;
            return false;
        }

        string line;
        while (getline(file, line)) {
            if (line == "$Nodes") {
                readNodes(file);
            } else if (line == "$Elements") {
                readElements(file);
            }
        }

        file.close();
        return true;
    }

    // Вывод информации о сетке
    void printMeshInfo() {
        cout << "\n===== Информация о сетке =====\n";
        cout << "Количество узлов: " << nodes.size() << endl;
        cout << "Количество элементов: " << elements.size() << endl;

        // Вывод первых 5 узлов
        cout << "\nПример узлов (первые 5):\n";
        for (size_t i = 0; i < min(nodes.size(), size_t(5)); ++i) {
            cout << "Node " << nodes[i].id << ": (" << nodes[i].x << ", " << nodes[i].y << ", " << nodes[i].z << ")\n";
        }

        // Вывод первых 5 элементов
        cout << "\nПример элементов (первые 5):\n";
        for (size_t i = 0; i < min(elements.size(), size_t(5)); ++i) {
            cout << "Element " << elements[i].id << " (Type " << elements[i].type << ") Nodes: ";
            for (int nid : elements[i].node_ids) cout << nid << " ";
            cout << endl;
        }
    }

    // Функция сохранения в .pvtu
    bool saveToPVTU(const string& filename) {
        ofstream file(filename);
        if (!file.is_open()) {
            cerr << "Ошибка: Не удалось создать файл " << filename << endl;
            return false;
        }

        file << "<?xml version=\"1.0\"?>\n";
        file << "<VTKFile type=\"PUnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\">\n";
        file << "  <PUnstructuredGrid GhostLevel=\"0\">\n";
        file << "    <PPoints>\n";
        file << "      <PDataArray type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\"/>\n";
        file << "    </PPoints>\n";

        file << "    <PCells>\n";
        file << "      <PDataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\"/>\n";
        file << "      <PDataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\"/>\n";
        file << "      <PDataArray type=\"UInt8\" Name=\"types\" format=\"ascii\"/>\n";
        file << "    </PCells>\n";

        file << "  </PUnstructuredGrid>\n";
        file << "</VTKFile>\n";

        file.close();
        cout << "Файл успешно сохранен: " << filename << endl;
        return true;
    }

private:
    // Чтение узлов из .msh
    void readNodes(ifstream& file) {
        int numEntityBlocks, numNodes, minNodeTag, maxNodeTag;
        file >> numEntityBlocks >> numNodes >> minNodeTag >> maxNodeTag;
        nodes.reserve(numNodes);

        for (int i = 0; i < numEntityBlocks; i++) {
            int entityDim, entityTag, parametric, numNodesInBlock;
            file >> entityDim >> entityTag >> parametric >> numNodesInBlock;

            vector<int> nodeTags(numNodesInBlock);
            for (int j = 0; j < numNodesInBlock; j++) {
                file >> nodeTags[j];
            }

            for (int j = 0; j < numNodesInBlock; j++) {
                double x, y, z;
                file >> x >> y >> z;
                nodes.push_back({nodeTags[j], x, y, z});
            }
        }
        string endLine;
        getline(file, endLine); // Пропускаем $EndNodes
    }

    // Чтение элементов из .msh
    void readElements(ifstream& file) {
        int numEntityBlocks, numElements, minElementTag, maxElementTag;
        file >> numEntityBlocks >> numElements >> minElementTag >> maxElementTag;
        elements.reserve(numElements);

        for (int i = 0; i < numEntityBlocks; i++) {
            int entityDim, entityTag, elementType, numElementsInBlock;
            file >> entityDim >> entityTag >> elementType >> numElementsInBlock;

            for (int j = 0; j < numElementsInBlock; j++) {
                int elementTag;
                file >> elementTag;

                vector<int> nodeTags;
                int numNodes = getNumNodesForElement(elementType);
                for (int k = 0; k < numNodes; k++) {
                    int nodeID;
                    file >> nodeID;
                    nodeTags.push_back(nodeID);
                }

                elements.push_back({elementTag, elementType, nodeTags});
            }
        }
        string endLine;
        getline(file, endLine); // Пропускаем $EndElements
    }

    // Определение количества узлов в элементе по типу Gmsh
    int getNumNodesForElement(int elementType) {
        switch (elementType) {
            case 15: return 1;  // Точка
            case 1: return 2;   // Линия
            case 2: return 3;   // Треугольник
            case 3: return 4;   // Квадрат
            case 4: return 4;   // Тетраэдр
            default: return 0;
        }
    }
};

// Главная функция
int main() {
    Mesh mesh;

    string msh_filename = "sava1.msh";  // Имя .msh файла
    string pvtu_filename = "output.pvtu"; // Имя выходного файла для ParaView

    if (mesh.loadMesh(msh_filename)) {
        cout << "Файл " << msh_filename << " успешно загружен!\n";
        mesh.printMeshInfo();
        mesh.saveToPVTU(pvtu_filename);
    } else {
        cout << "Ошибка при загрузке файла.\n";
    }

    return 0;
}
