#include <iostream>
#include <cmath>
#include <locale>

using namespace std;

// Подынтегральная функция f(x) = 1 / (x + sin(0.1 * n * x))
// Эта функция возвращает значение подынтегральной функции в точке x для заданного параметра n
double f(double x, double n) {
    return 1.0 / (x + sin(0.1 * n * x));
}

// Функция для вычисления полинома ω(x) для заданных узлов
// ω(x) = ∏_{k=0, k≠i}^{N} (x - x_k)
double omega(double x, double* nodes, int N) {
    double result = 1.0;
    for (int k = 0; k <= N; ++k) {
        result *= (x - nodes[k]);
    }
    return result;
}

// Производная ω'(x_i) для узла x_i
// Вычисляем производную ω(x) = ∏_{k=0, k≠i}^{N} (x - x_k) в точке x_i
double omega_derivative(double x_i, double* nodes, int N) {
    double derivative = 0.0;

    // Сумма по каждому элементу для производной от ω(x) в узле x_i
    for (int k = 0; k <= N; ++k) {
        if (k != i) {
            double term = 1.0;
            // Произведение всех (x_i - x_j) для j ≠ k, j ≠ i
            for (int j = 0; j <= N; ++j) {
                if (j != k && j != i) {
                    term *= (x_i - nodes[j]);
                }
            }
            derivative += term;
        }
    }

    return derivative;
}

// Функция для вычисления весового коэффициента C_i
// Вычисляем C_i по формуле (24)
double calculate_Ci(int i, double* nodes, int N, double a, double b) {
    double Ci = 0.0;
    int steps = 10000;  // Количество шагов для численного интегрирования
    double h = (b - a) / steps;

    for (int j = 0; j < steps; ++j) {
        double x = a + j * h;
        double omega_val = omega(x, nodes, N);
        if (omega_val != 0) {
            Ci += omega_val / ((x - nodes[i]) * omega_derivative(nodes[i], nodes, N));
        }
    }
    Ci *= h;  // Умножаем на шаг интегрирования для получения приближенного значения
    return Ci;
}

int main() {
    setlocale(LC_ALL, "Russian");

    double n = 5.0;  // Параметр n для подынтегральной функции
    double a = 0.2 * n;  // Нижний предел интегрирования
    double b = 2.0 * n;  // Верхний предел интегрирования
    int N = 2;  // Количество узлов интерполяции

    // Массив для хранения узлов интерполяции
    double* nodes = new double[N + 1];

    // Определяем равномерные узлы на отрезке [a, b]
    for (int i = 0; i <= N; ++i) {
        nodes[i] = a + i * (b - a) / N;
    }

    // Переменная для хранения значения интеграла
    double integral = 0.0;

    // Шаг 1: Вычисляем значение интеграла с использованием формул интерполяционного типа
    for (int i = 0; i <= N; ++i) {
        double Ci = calculate_Ci(i, nodes, N, a, b);  // Вычисляем весовой коэффициент C_i
        integral += Ci * f(nodes[i], n);  // Добавляем вклад каждого узла в интеграл
    }

    // Выводим результат
    cout << "Значение интеграла I1 с использованием формул интерполяционного типа = " << integral << endl;

    // Освобождаем динамически выделенную память
    delete[] nodes;

    return 0;
}
