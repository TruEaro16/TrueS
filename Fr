#include <iostream>
#include <cmath> // Для использования математических функций
#include <locale.h> // Для установки русского языка

using namespace std;

// Функция f(x, y) для варианта 5
double f(double x, double y) {
    return x * sin(x) * exp(-x * x) - 2 * x * y;
}

// Точное решение задачи Коши (если известно, для демонстрации возьмем примерную функцию)
double exact_solution(double x) {
    // Здесь предполагается, что точное решение известно.
    // Замените эту функцию точным решением, если оно есть.
    return exp(-x * x); // Пример функции точного решения
}

int main() {
    // Устанавливаем русскую локализацию для вывода текста
    setlocale(LC_ALL, "Russian");

    // Входные данные
    double a = 0; // Начальная точка
    double b = 1; // Конечная точка
    int N = 10;   // Количество точек разбиения (можно увеличить N для большей точности)
    double y0 = 1; // Начальное условие: y(0) = 1
    double h = (b - a) / N; // Шаг

    // Динамические массивы для хранения значений x, y (приближения), y_exact (точное решение)
    double* x = new double[N + 1];
    double* y_prev = new double[N + 1]; // Предыдущее приближение
    double* y_curr = new double[N + 1]; // Текущее приближение
    double* y_exact = new double[N + 1]; // Точное решение

    // Заполняем массив x значениями
    for (int i = 0; i <= N; i++) {
        x[i] = a + i * h; // равномерное разбиение от a до b
        y_exact[i] = exact_solution(x[i]); // Заполняем массив точного решения
    }

    // Начальное приближение: y(0)(x) = y0 (постоянная функция)
    for (int i = 0; i <= N; i++) {
        y_prev[i] = y0;
    }

    // Итерационный процесс метода Пикара
    for (int k = 0; k < 5; k++) { // Проводим 5 итераций
        // Первое значение всегда равно y0
        y_curr[0] = y0;

        // Для каждого узла x[i] вычисляем новое значение y
        for (int i = 1; i <= N; i++) {
            double integral = 0.0;

            // Приближенное вычисление интеграла методом прямоугольников
            for (int j = 0; j < i; j++) {
                integral += f(x[j], y_prev[j]) * h;
            }

            // Новое приближение
            y_curr[i] = y0 + integral;
        }

        // Копируем текущее приближение в предыдущее для следующей итерации
        for (int i = 0; i <= N; i++) {
            y_prev[i] = y_curr[i];
        }
    }

    // Выводим таблицу результатов
    cout << "Узел\tЧисленное решение\tТочное решение\tПогрешность\n";
    cout << "---------------------------------------------------------\n";
    for (int i = 0; i <= N; i++) {
        double error = abs(y_curr[i] - y_exact[i]); // Вычисляем погрешность
        cout << x[i] << "\t" << y_curr[i] << "\t\t" << y_exact[i] << "\t\t" << error << endl;
    }

    // Освобождаем динамически выделенную память
    delete[] x;
    delete[] y_prev;
    delete[] y_curr;
    delete[] y_exact;

    return 0;
}
