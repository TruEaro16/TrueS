#include <iostream>
#include <cmath> // Для использования математических функций
#include <locale.h> // Для установки русского языка

using namespace std;

// Функция f(x, y) для варианта 5
double f(double x, double y) {
    return x * sin(x) * exp(-x * x) - 2 * x * y;
}

int main() {
    // Устанавливаем русскую локализацию для вывода текста
    setlocale(LC_ALL, "Russian");

    // Входные данные
    double a = 0; // Начальная точка
    double b = 1; // Конечная точка
    int N = 10;   // Количество точек разбиения (чем больше, тем точнее)
    double y0 = 1; // Начальное условие: y(0) = 1
    double h = (b - a) / N; // Шаг

    // Динамические массивы для хранения значений x и y
    double* x = new double[N + 1];
    double* y_prev = new double[N + 1]; // Предыдущее приближение
    double* y_curr = new double[N + 1]; // Текущее приближение

    // Заполняем массив x значениями
    for (int i = 0; i <= N; i++) {
        x[i] = a + i * h; // равномерное разбиение от a до b
    }

    // Начальное приближение: y(0)(x) = y0 (постоянная функция)
    for (int i = 0; i <= N; i++) {
        y_prev[i] = y0;
    }

    // Итерационный процесс метода Пикара
    for (int k = 0; k < 5; k++) { // Проводим 5 итераций
        // Первое значение всегда равно y0
        y_curr[0] = y0;

        // Для каждого узла x[i] вычисляем новое значение y
        for (int i = 1; i <= N; i++) {
            double integral = 0.0;

            // Приближенное вычисление интеграла методом прямоугольников
            for (int j = 0; j < i; j++) {
                integral += f(x[j], y_prev[j]) * h;
            }

            // Новое приближение
            y_curr[i] = y0 + integral;
        }

        // Копируем текущее приближение в предыдущее для следующей итерации
        for (int i = 0; i <= N; i++) {
            y_prev[i] = y_curr[i];
        }

        // Выводим промежуточные результаты каждой итерации
        cout << "Итерация " << k + 1 << ": ";
        for (int i = 0; i <= N; i++) {
            cout << y_curr[i] << " ";
        }
        cout << endl;
    }

    // Освобождаем динамически выделенную память
    delete[] x;
    delete[] y_prev;
    delete[] y_curr;

    return 0;
}
